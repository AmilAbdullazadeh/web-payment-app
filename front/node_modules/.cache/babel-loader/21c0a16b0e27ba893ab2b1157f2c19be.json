{"ast":null,"code":"import contains from 'dom-helpers/contains';\nimport listen from 'dom-helpers/listen';\nimport ownerDocument from 'dom-helpers/ownerDocument';\nimport { useCallback, useEffect, useRef } from 'react';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport warning from 'warning';\nconst escapeKeyCode = 27;\n\nconst noop = () => {};\n\nfunction isLeftClickEvent(event) {\n  return event.button === 0;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nconst getRefTarget = ref => ref && ('current' in ref ? ref.current : ref);\n/**\n * The `useRootClose` hook registers your callback on the document\n * when rendered. Powers the `<Overlay/>` component. This is used achieve modal\n * style behavior where your callback is triggered when the user tries to\n * interact with the rest of the document or hits the `esc` key.\n *\n * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary\n * @param {function} onRootClose\n * @param {object=}  options\n * @param {boolean=} options.disabled\n * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on\n */\n\n\nfunction useRootClose(ref, onRootClose, {\n  disabled,\n  clickTrigger = 'click'\n} = {}) {\n  const preventMouseRootCloseRef = useRef(false);\n  const onClose = onRootClose || noop;\n  const handleMouseCapture = useCallback(e => {\n    const currentTarget = getRefTarget(ref);\n    warning(!!currentTarget, 'RootClose captured a close event but does not have a ref to compare it to. ' + 'useRootClose(), should be passed a ref that resolves to a DOM node');\n    preventMouseRootCloseRef.current = !currentTarget || isModifiedEvent(e) || !isLeftClickEvent(e) || !!contains(currentTarget, e.target);\n  }, [ref]);\n  const handleMouse = useEventCallback(e => {\n    if (!preventMouseRootCloseRef.current) {\n      onClose(e);\n    }\n  });\n  const handleKeyUp = useEventCallback(e => {\n    if (e.keyCode === escapeKeyCode) {\n      onClose(e);\n    }\n  });\n  useEffect(() => {\n    if (disabled || ref == null) return undefined; // Store the current event to avoid triggering handlers immediately\n    // https://github.com/facebook/react/issues/20074\n\n    let currentEvent = window.event;\n    const doc = ownerDocument(getRefTarget(ref)); // Use capture for this listener so it fires before React's listener, to\n    // avoid false positives in the contains() check below if the target DOM\n    // element is removed in the React mouse callback.\n\n    const removeMouseCaptureListener = listen(doc, clickTrigger, handleMouseCapture, true);\n    const removeMouseListener = listen(doc, clickTrigger, e => {\n      // skip if this event is the same as the one running when we added the handlers\n      if (e === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n\n      handleMouse(e);\n    });\n    const removeKeyupListener = listen(doc, 'keyup', e => {\n      // skip if this event is the same as the one running when we added the handlers\n      if (e === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n\n      handleKeyUp(e);\n    });\n    let mobileSafariHackListeners = [];\n\n    if ('ontouchstart' in doc.documentElement) {\n      mobileSafariHackListeners = [].slice.call(doc.body.children).map(el => listen(el, 'mousemove', noop));\n    }\n\n    return () => {\n      removeMouseCaptureListener();\n      removeMouseListener();\n      removeKeyupListener();\n      mobileSafariHackListeners.forEach(remove => remove());\n    };\n  }, [ref, disabled, clickTrigger, handleMouseCapture, handleMouse, handleKeyUp]);\n}\n\nexport default useRootClose;","map":{"version":3,"sources":["/Users/amilabdullayev/Desktop/Projects/web-payment-app/node_modules/@restart/ui/esm/useRootClose.js"],"names":["contains","listen","ownerDocument","useCallback","useEffect","useRef","useEventCallback","warning","escapeKeyCode","noop","isLeftClickEvent","event","button","isModifiedEvent","metaKey","altKey","ctrlKey","shiftKey","getRefTarget","ref","current","useRootClose","onRootClose","disabled","clickTrigger","preventMouseRootCloseRef","onClose","handleMouseCapture","e","currentTarget","target","handleMouse","handleKeyUp","keyCode","undefined","currentEvent","window","doc","removeMouseCaptureListener","removeMouseListener","removeKeyupListener","mobileSafariHackListeners","documentElement","slice","call","body","children","map","el","forEach","remove"],"mappings":"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","sourcesContent":["import contains from 'dom-helpers/contains';\nimport listen from 'dom-helpers/listen';\nimport ownerDocument from 'dom-helpers/ownerDocument';\nimport { useCallback, useEffect, useRef } from 'react';\nimport useEventCallback from '@restart/hooks/useEventCallback';\nimport warning from 'warning';\nconst escapeKeyCode = 27;\n\nconst noop = () => {};\n\nfunction isLeftClickEvent(event) {\n  return event.button === 0;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nconst getRefTarget = ref => ref && ('current' in ref ? ref.current : ref);\n\n/**\n * The `useRootClose` hook registers your callback on the document\n * when rendered. Powers the `<Overlay/>` component. This is used achieve modal\n * style behavior where your callback is triggered when the user tries to\n * interact with the rest of the document or hits the `esc` key.\n *\n * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary\n * @param {function} onRootClose\n * @param {object=}  options\n * @param {boolean=} options.disabled\n * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on\n */\nfunction useRootClose(ref, onRootClose, {\n  disabled,\n  clickTrigger = 'click'\n} = {}) {\n  const preventMouseRootCloseRef = useRef(false);\n  const onClose = onRootClose || noop;\n  const handleMouseCapture = useCallback(e => {\n    const currentTarget = getRefTarget(ref);\n    warning(!!currentTarget, 'RootClose captured a close event but does not have a ref to compare it to. ' + 'useRootClose(), should be passed a ref that resolves to a DOM node');\n    preventMouseRootCloseRef.current = !currentTarget || isModifiedEvent(e) || !isLeftClickEvent(e) || !!contains(currentTarget, e.target);\n  }, [ref]);\n  const handleMouse = useEventCallback(e => {\n    if (!preventMouseRootCloseRef.current) {\n      onClose(e);\n    }\n  });\n  const handleKeyUp = useEventCallback(e => {\n    if (e.keyCode === escapeKeyCode) {\n      onClose(e);\n    }\n  });\n  useEffect(() => {\n    if (disabled || ref == null) return undefined; // Store the current event to avoid triggering handlers immediately\n    // https://github.com/facebook/react/issues/20074\n\n    let currentEvent = window.event;\n    const doc = ownerDocument(getRefTarget(ref)); // Use capture for this listener so it fires before React's listener, to\n    // avoid false positives in the contains() check below if the target DOM\n    // element is removed in the React mouse callback.\n\n    const removeMouseCaptureListener = listen(doc, clickTrigger, handleMouseCapture, true);\n    const removeMouseListener = listen(doc, clickTrigger, e => {\n      // skip if this event is the same as the one running when we added the handlers\n      if (e === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n\n      handleMouse(e);\n    });\n    const removeKeyupListener = listen(doc, 'keyup', e => {\n      // skip if this event is the same as the one running when we added the handlers\n      if (e === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n\n      handleKeyUp(e);\n    });\n    let mobileSafariHackListeners = [];\n\n    if ('ontouchstart' in doc.documentElement) {\n      mobileSafariHackListeners = [].slice.call(doc.body.children).map(el => listen(el, 'mousemove', noop));\n    }\n\n    return () => {\n      removeMouseCaptureListener();\n      removeMouseListener();\n      removeKeyupListener();\n      mobileSafariHackListeners.forEach(remove => remove());\n    };\n  }, [ref, disabled, clickTrigger, handleMouseCapture, handleMouse, handleKeyUp]);\n}\n\nexport default useRootClose;"]},"metadata":{},"sourceType":"module"}